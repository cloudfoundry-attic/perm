// Code generated by counterfeiter. DO NOT EDIT.
package protosfakes

import (
	"sync"

	"code.cloudfoundry.org/perm/pkg/api/protos"
	_ "github.com/gogo/protobuf/gogoproto"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
)

type FakeRoleServiceClient struct {
	CreateRoleStub        func(ctx context.Context, in *protos.CreateRoleRequest, opts ...grpc.CallOption) (*protos.CreateRoleResponse, error)
	createRoleMutex       sync.RWMutex
	createRoleArgsForCall []struct {
		ctx  context.Context
		in   *protos.CreateRoleRequest
		opts []grpc.CallOption
	}
	createRoleReturns struct {
		result1 *protos.CreateRoleResponse
		result2 error
	}
	createRoleReturnsOnCall map[int]struct {
		result1 *protos.CreateRoleResponse
		result2 error
	}
	DeleteRoleStub        func(ctx context.Context, in *protos.DeleteRoleRequest, opts ...grpc.CallOption) (*protos.DeleteRoleResponse, error)
	deleteRoleMutex       sync.RWMutex
	deleteRoleArgsForCall []struct {
		ctx  context.Context
		in   *protos.DeleteRoleRequest
		opts []grpc.CallOption
	}
	deleteRoleReturns struct {
		result1 *protos.DeleteRoleResponse
		result2 error
	}
	deleteRoleReturnsOnCall map[int]struct {
		result1 *protos.DeleteRoleResponse
		result2 error
	}
	AssignRoleStub        func(ctx context.Context, in *protos.AssignRoleRequest, opts ...grpc.CallOption) (*protos.AssignRoleResponse, error)
	assignRoleMutex       sync.RWMutex
	assignRoleArgsForCall []struct {
		ctx  context.Context
		in   *protos.AssignRoleRequest
		opts []grpc.CallOption
	}
	assignRoleReturns struct {
		result1 *protos.AssignRoleResponse
		result2 error
	}
	assignRoleReturnsOnCall map[int]struct {
		result1 *protos.AssignRoleResponse
		result2 error
	}
	AssignRoleToGroupStub        func(ctx context.Context, in *protos.AssignRoleToGroupRequest, opts ...grpc.CallOption) (*protos.AssignRoleToGroupResponse, error)
	assignRoleToGroupMutex       sync.RWMutex
	assignRoleToGroupArgsForCall []struct {
		ctx  context.Context
		in   *protos.AssignRoleToGroupRequest
		opts []grpc.CallOption
	}
	assignRoleToGroupReturns struct {
		result1 *protos.AssignRoleToGroupResponse
		result2 error
	}
	assignRoleToGroupReturnsOnCall map[int]struct {
		result1 *protos.AssignRoleToGroupResponse
		result2 error
	}
	UnassignRoleStub        func(ctx context.Context, in *protos.UnassignRoleRequest, opts ...grpc.CallOption) (*protos.UnassignRoleResponse, error)
	unassignRoleMutex       sync.RWMutex
	unassignRoleArgsForCall []struct {
		ctx  context.Context
		in   *protos.UnassignRoleRequest
		opts []grpc.CallOption
	}
	unassignRoleReturns struct {
		result1 *protos.UnassignRoleResponse
		result2 error
	}
	unassignRoleReturnsOnCall map[int]struct {
		result1 *protos.UnassignRoleResponse
		result2 error
	}
	UnassignRoleFromGroupStub        func(ctx context.Context, in *protos.UnassignRoleFromGroupRequest, opts ...grpc.CallOption) (*protos.UnassignRoleFromGroupResponse, error)
	unassignRoleFromGroupMutex       sync.RWMutex
	unassignRoleFromGroupArgsForCall []struct {
		ctx  context.Context
		in   *protos.UnassignRoleFromGroupRequest
		opts []grpc.CallOption
	}
	unassignRoleFromGroupReturns struct {
		result1 *protos.UnassignRoleFromGroupResponse
		result2 error
	}
	unassignRoleFromGroupReturnsOnCall map[int]struct {
		result1 *protos.UnassignRoleFromGroupResponse
		result2 error
	}
	HasRoleStub        func(ctx context.Context, in *protos.HasRoleRequest, opts ...grpc.CallOption) (*protos.HasRoleResponse, error)
	hasRoleMutex       sync.RWMutex
	hasRoleArgsForCall []struct {
		ctx  context.Context
		in   *protos.HasRoleRequest
		opts []grpc.CallOption
	}
	hasRoleReturns struct {
		result1 *protos.HasRoleResponse
		result2 error
	}
	hasRoleReturnsOnCall map[int]struct {
		result1 *protos.HasRoleResponse
		result2 error
	}
	HasRoleForGroupStub        func(ctx context.Context, in *protos.HasRoleForGroupRequest, opts ...grpc.CallOption) (*protos.HasRoleForGroupResponse, error)
	hasRoleForGroupMutex       sync.RWMutex
	hasRoleForGroupArgsForCall []struct {
		ctx  context.Context
		in   *protos.HasRoleForGroupRequest
		opts []grpc.CallOption
	}
	hasRoleForGroupReturns struct {
		result1 *protos.HasRoleForGroupResponse
		result2 error
	}
	hasRoleForGroupReturnsOnCall map[int]struct {
		result1 *protos.HasRoleForGroupResponse
		result2 error
	}
	ListRolePermissionsStub        func(ctx context.Context, in *protos.ListRolePermissionsRequest, opts ...grpc.CallOption) (*protos.ListRolePermissionsResponse, error)
	listRolePermissionsMutex       sync.RWMutex
	listRolePermissionsArgsForCall []struct {
		ctx  context.Context
		in   *protos.ListRolePermissionsRequest
		opts []grpc.CallOption
	}
	listRolePermissionsReturns struct {
		result1 *protos.ListRolePermissionsResponse
		result2 error
	}
	listRolePermissionsReturnsOnCall map[int]struct {
		result1 *protos.ListRolePermissionsResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRoleServiceClient) CreateRole(ctx context.Context, in *protos.CreateRoleRequest, opts ...grpc.CallOption) (*protos.CreateRoleResponse, error) {
	fake.createRoleMutex.Lock()
	ret, specificReturn := fake.createRoleReturnsOnCall[len(fake.createRoleArgsForCall)]
	fake.createRoleArgsForCall = append(fake.createRoleArgsForCall, struct {
		ctx  context.Context
		in   *protos.CreateRoleRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("CreateRole", []interface{}{ctx, in, opts})
	fake.createRoleMutex.Unlock()
	if fake.CreateRoleStub != nil {
		return fake.CreateRoleStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createRoleReturns.result1, fake.createRoleReturns.result2
}

func (fake *FakeRoleServiceClient) CreateRoleCallCount() int {
	fake.createRoleMutex.RLock()
	defer fake.createRoleMutex.RUnlock()
	return len(fake.createRoleArgsForCall)
}

func (fake *FakeRoleServiceClient) CreateRoleArgsForCall(i int) (context.Context, *protos.CreateRoleRequest, []grpc.CallOption) {
	fake.createRoleMutex.RLock()
	defer fake.createRoleMutex.RUnlock()
	return fake.createRoleArgsForCall[i].ctx, fake.createRoleArgsForCall[i].in, fake.createRoleArgsForCall[i].opts
}

func (fake *FakeRoleServiceClient) CreateRoleReturns(result1 *protos.CreateRoleResponse, result2 error) {
	fake.CreateRoleStub = nil
	fake.createRoleReturns = struct {
		result1 *protos.CreateRoleResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) CreateRoleReturnsOnCall(i int, result1 *protos.CreateRoleResponse, result2 error) {
	fake.CreateRoleStub = nil
	if fake.createRoleReturnsOnCall == nil {
		fake.createRoleReturnsOnCall = make(map[int]struct {
			result1 *protos.CreateRoleResponse
			result2 error
		})
	}
	fake.createRoleReturnsOnCall[i] = struct {
		result1 *protos.CreateRoleResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) DeleteRole(ctx context.Context, in *protos.DeleteRoleRequest, opts ...grpc.CallOption) (*protos.DeleteRoleResponse, error) {
	fake.deleteRoleMutex.Lock()
	ret, specificReturn := fake.deleteRoleReturnsOnCall[len(fake.deleteRoleArgsForCall)]
	fake.deleteRoleArgsForCall = append(fake.deleteRoleArgsForCall, struct {
		ctx  context.Context
		in   *protos.DeleteRoleRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("DeleteRole", []interface{}{ctx, in, opts})
	fake.deleteRoleMutex.Unlock()
	if fake.DeleteRoleStub != nil {
		return fake.DeleteRoleStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deleteRoleReturns.result1, fake.deleteRoleReturns.result2
}

func (fake *FakeRoleServiceClient) DeleteRoleCallCount() int {
	fake.deleteRoleMutex.RLock()
	defer fake.deleteRoleMutex.RUnlock()
	return len(fake.deleteRoleArgsForCall)
}

func (fake *FakeRoleServiceClient) DeleteRoleArgsForCall(i int) (context.Context, *protos.DeleteRoleRequest, []grpc.CallOption) {
	fake.deleteRoleMutex.RLock()
	defer fake.deleteRoleMutex.RUnlock()
	return fake.deleteRoleArgsForCall[i].ctx, fake.deleteRoleArgsForCall[i].in, fake.deleteRoleArgsForCall[i].opts
}

func (fake *FakeRoleServiceClient) DeleteRoleReturns(result1 *protos.DeleteRoleResponse, result2 error) {
	fake.DeleteRoleStub = nil
	fake.deleteRoleReturns = struct {
		result1 *protos.DeleteRoleResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) DeleteRoleReturnsOnCall(i int, result1 *protos.DeleteRoleResponse, result2 error) {
	fake.DeleteRoleStub = nil
	if fake.deleteRoleReturnsOnCall == nil {
		fake.deleteRoleReturnsOnCall = make(map[int]struct {
			result1 *protos.DeleteRoleResponse
			result2 error
		})
	}
	fake.deleteRoleReturnsOnCall[i] = struct {
		result1 *protos.DeleteRoleResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) AssignRole(ctx context.Context, in *protos.AssignRoleRequest, opts ...grpc.CallOption) (*protos.AssignRoleResponse, error) {
	fake.assignRoleMutex.Lock()
	ret, specificReturn := fake.assignRoleReturnsOnCall[len(fake.assignRoleArgsForCall)]
	fake.assignRoleArgsForCall = append(fake.assignRoleArgsForCall, struct {
		ctx  context.Context
		in   *protos.AssignRoleRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("AssignRole", []interface{}{ctx, in, opts})
	fake.assignRoleMutex.Unlock()
	if fake.AssignRoleStub != nil {
		return fake.AssignRoleStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.assignRoleReturns.result1, fake.assignRoleReturns.result2
}

func (fake *FakeRoleServiceClient) AssignRoleCallCount() int {
	fake.assignRoleMutex.RLock()
	defer fake.assignRoleMutex.RUnlock()
	return len(fake.assignRoleArgsForCall)
}

func (fake *FakeRoleServiceClient) AssignRoleArgsForCall(i int) (context.Context, *protos.AssignRoleRequest, []grpc.CallOption) {
	fake.assignRoleMutex.RLock()
	defer fake.assignRoleMutex.RUnlock()
	return fake.assignRoleArgsForCall[i].ctx, fake.assignRoleArgsForCall[i].in, fake.assignRoleArgsForCall[i].opts
}

func (fake *FakeRoleServiceClient) AssignRoleReturns(result1 *protos.AssignRoleResponse, result2 error) {
	fake.AssignRoleStub = nil
	fake.assignRoleReturns = struct {
		result1 *protos.AssignRoleResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) AssignRoleReturnsOnCall(i int, result1 *protos.AssignRoleResponse, result2 error) {
	fake.AssignRoleStub = nil
	if fake.assignRoleReturnsOnCall == nil {
		fake.assignRoleReturnsOnCall = make(map[int]struct {
			result1 *protos.AssignRoleResponse
			result2 error
		})
	}
	fake.assignRoleReturnsOnCall[i] = struct {
		result1 *protos.AssignRoleResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) AssignRoleToGroup(ctx context.Context, in *protos.AssignRoleToGroupRequest, opts ...grpc.CallOption) (*protos.AssignRoleToGroupResponse, error) {
	fake.assignRoleToGroupMutex.Lock()
	ret, specificReturn := fake.assignRoleToGroupReturnsOnCall[len(fake.assignRoleToGroupArgsForCall)]
	fake.assignRoleToGroupArgsForCall = append(fake.assignRoleToGroupArgsForCall, struct {
		ctx  context.Context
		in   *protos.AssignRoleToGroupRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("AssignRoleToGroup", []interface{}{ctx, in, opts})
	fake.assignRoleToGroupMutex.Unlock()
	if fake.AssignRoleToGroupStub != nil {
		return fake.AssignRoleToGroupStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.assignRoleToGroupReturns.result1, fake.assignRoleToGroupReturns.result2
}

func (fake *FakeRoleServiceClient) AssignRoleToGroupCallCount() int {
	fake.assignRoleToGroupMutex.RLock()
	defer fake.assignRoleToGroupMutex.RUnlock()
	return len(fake.assignRoleToGroupArgsForCall)
}

func (fake *FakeRoleServiceClient) AssignRoleToGroupArgsForCall(i int) (context.Context, *protos.AssignRoleToGroupRequest, []grpc.CallOption) {
	fake.assignRoleToGroupMutex.RLock()
	defer fake.assignRoleToGroupMutex.RUnlock()
	return fake.assignRoleToGroupArgsForCall[i].ctx, fake.assignRoleToGroupArgsForCall[i].in, fake.assignRoleToGroupArgsForCall[i].opts
}

func (fake *FakeRoleServiceClient) AssignRoleToGroupReturns(result1 *protos.AssignRoleToGroupResponse, result2 error) {
	fake.AssignRoleToGroupStub = nil
	fake.assignRoleToGroupReturns = struct {
		result1 *protos.AssignRoleToGroupResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) AssignRoleToGroupReturnsOnCall(i int, result1 *protos.AssignRoleToGroupResponse, result2 error) {
	fake.AssignRoleToGroupStub = nil
	if fake.assignRoleToGroupReturnsOnCall == nil {
		fake.assignRoleToGroupReturnsOnCall = make(map[int]struct {
			result1 *protos.AssignRoleToGroupResponse
			result2 error
		})
	}
	fake.assignRoleToGroupReturnsOnCall[i] = struct {
		result1 *protos.AssignRoleToGroupResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) UnassignRole(ctx context.Context, in *protos.UnassignRoleRequest, opts ...grpc.CallOption) (*protos.UnassignRoleResponse, error) {
	fake.unassignRoleMutex.Lock()
	ret, specificReturn := fake.unassignRoleReturnsOnCall[len(fake.unassignRoleArgsForCall)]
	fake.unassignRoleArgsForCall = append(fake.unassignRoleArgsForCall, struct {
		ctx  context.Context
		in   *protos.UnassignRoleRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("UnassignRole", []interface{}{ctx, in, opts})
	fake.unassignRoleMutex.Unlock()
	if fake.UnassignRoleStub != nil {
		return fake.UnassignRoleStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.unassignRoleReturns.result1, fake.unassignRoleReturns.result2
}

func (fake *FakeRoleServiceClient) UnassignRoleCallCount() int {
	fake.unassignRoleMutex.RLock()
	defer fake.unassignRoleMutex.RUnlock()
	return len(fake.unassignRoleArgsForCall)
}

func (fake *FakeRoleServiceClient) UnassignRoleArgsForCall(i int) (context.Context, *protos.UnassignRoleRequest, []grpc.CallOption) {
	fake.unassignRoleMutex.RLock()
	defer fake.unassignRoleMutex.RUnlock()
	return fake.unassignRoleArgsForCall[i].ctx, fake.unassignRoleArgsForCall[i].in, fake.unassignRoleArgsForCall[i].opts
}

func (fake *FakeRoleServiceClient) UnassignRoleReturns(result1 *protos.UnassignRoleResponse, result2 error) {
	fake.UnassignRoleStub = nil
	fake.unassignRoleReturns = struct {
		result1 *protos.UnassignRoleResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) UnassignRoleReturnsOnCall(i int, result1 *protos.UnassignRoleResponse, result2 error) {
	fake.UnassignRoleStub = nil
	if fake.unassignRoleReturnsOnCall == nil {
		fake.unassignRoleReturnsOnCall = make(map[int]struct {
			result1 *protos.UnassignRoleResponse
			result2 error
		})
	}
	fake.unassignRoleReturnsOnCall[i] = struct {
		result1 *protos.UnassignRoleResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) UnassignRoleFromGroup(ctx context.Context, in *protos.UnassignRoleFromGroupRequest, opts ...grpc.CallOption) (*protos.UnassignRoleFromGroupResponse, error) {
	fake.unassignRoleFromGroupMutex.Lock()
	ret, specificReturn := fake.unassignRoleFromGroupReturnsOnCall[len(fake.unassignRoleFromGroupArgsForCall)]
	fake.unassignRoleFromGroupArgsForCall = append(fake.unassignRoleFromGroupArgsForCall, struct {
		ctx  context.Context
		in   *protos.UnassignRoleFromGroupRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("UnassignRoleFromGroup", []interface{}{ctx, in, opts})
	fake.unassignRoleFromGroupMutex.Unlock()
	if fake.UnassignRoleFromGroupStub != nil {
		return fake.UnassignRoleFromGroupStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.unassignRoleFromGroupReturns.result1, fake.unassignRoleFromGroupReturns.result2
}

func (fake *FakeRoleServiceClient) UnassignRoleFromGroupCallCount() int {
	fake.unassignRoleFromGroupMutex.RLock()
	defer fake.unassignRoleFromGroupMutex.RUnlock()
	return len(fake.unassignRoleFromGroupArgsForCall)
}

func (fake *FakeRoleServiceClient) UnassignRoleFromGroupArgsForCall(i int) (context.Context, *protos.UnassignRoleFromGroupRequest, []grpc.CallOption) {
	fake.unassignRoleFromGroupMutex.RLock()
	defer fake.unassignRoleFromGroupMutex.RUnlock()
	return fake.unassignRoleFromGroupArgsForCall[i].ctx, fake.unassignRoleFromGroupArgsForCall[i].in, fake.unassignRoleFromGroupArgsForCall[i].opts
}

func (fake *FakeRoleServiceClient) UnassignRoleFromGroupReturns(result1 *protos.UnassignRoleFromGroupResponse, result2 error) {
	fake.UnassignRoleFromGroupStub = nil
	fake.unassignRoleFromGroupReturns = struct {
		result1 *protos.UnassignRoleFromGroupResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) UnassignRoleFromGroupReturnsOnCall(i int, result1 *protos.UnassignRoleFromGroupResponse, result2 error) {
	fake.UnassignRoleFromGroupStub = nil
	if fake.unassignRoleFromGroupReturnsOnCall == nil {
		fake.unassignRoleFromGroupReturnsOnCall = make(map[int]struct {
			result1 *protos.UnassignRoleFromGroupResponse
			result2 error
		})
	}
	fake.unassignRoleFromGroupReturnsOnCall[i] = struct {
		result1 *protos.UnassignRoleFromGroupResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) HasRole(ctx context.Context, in *protos.HasRoleRequest, opts ...grpc.CallOption) (*protos.HasRoleResponse, error) {
	fake.hasRoleMutex.Lock()
	ret, specificReturn := fake.hasRoleReturnsOnCall[len(fake.hasRoleArgsForCall)]
	fake.hasRoleArgsForCall = append(fake.hasRoleArgsForCall, struct {
		ctx  context.Context
		in   *protos.HasRoleRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("HasRole", []interface{}{ctx, in, opts})
	fake.hasRoleMutex.Unlock()
	if fake.HasRoleStub != nil {
		return fake.HasRoleStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.hasRoleReturns.result1, fake.hasRoleReturns.result2
}

func (fake *FakeRoleServiceClient) HasRoleCallCount() int {
	fake.hasRoleMutex.RLock()
	defer fake.hasRoleMutex.RUnlock()
	return len(fake.hasRoleArgsForCall)
}

func (fake *FakeRoleServiceClient) HasRoleArgsForCall(i int) (context.Context, *protos.HasRoleRequest, []grpc.CallOption) {
	fake.hasRoleMutex.RLock()
	defer fake.hasRoleMutex.RUnlock()
	return fake.hasRoleArgsForCall[i].ctx, fake.hasRoleArgsForCall[i].in, fake.hasRoleArgsForCall[i].opts
}

func (fake *FakeRoleServiceClient) HasRoleReturns(result1 *protos.HasRoleResponse, result2 error) {
	fake.HasRoleStub = nil
	fake.hasRoleReturns = struct {
		result1 *protos.HasRoleResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) HasRoleReturnsOnCall(i int, result1 *protos.HasRoleResponse, result2 error) {
	fake.HasRoleStub = nil
	if fake.hasRoleReturnsOnCall == nil {
		fake.hasRoleReturnsOnCall = make(map[int]struct {
			result1 *protos.HasRoleResponse
			result2 error
		})
	}
	fake.hasRoleReturnsOnCall[i] = struct {
		result1 *protos.HasRoleResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) HasRoleForGroup(ctx context.Context, in *protos.HasRoleForGroupRequest, opts ...grpc.CallOption) (*protos.HasRoleForGroupResponse, error) {
	fake.hasRoleForGroupMutex.Lock()
	ret, specificReturn := fake.hasRoleForGroupReturnsOnCall[len(fake.hasRoleForGroupArgsForCall)]
	fake.hasRoleForGroupArgsForCall = append(fake.hasRoleForGroupArgsForCall, struct {
		ctx  context.Context
		in   *protos.HasRoleForGroupRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("HasRoleForGroup", []interface{}{ctx, in, opts})
	fake.hasRoleForGroupMutex.Unlock()
	if fake.HasRoleForGroupStub != nil {
		return fake.HasRoleForGroupStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.hasRoleForGroupReturns.result1, fake.hasRoleForGroupReturns.result2
}

func (fake *FakeRoleServiceClient) HasRoleForGroupCallCount() int {
	fake.hasRoleForGroupMutex.RLock()
	defer fake.hasRoleForGroupMutex.RUnlock()
	return len(fake.hasRoleForGroupArgsForCall)
}

func (fake *FakeRoleServiceClient) HasRoleForGroupArgsForCall(i int) (context.Context, *protos.HasRoleForGroupRequest, []grpc.CallOption) {
	fake.hasRoleForGroupMutex.RLock()
	defer fake.hasRoleForGroupMutex.RUnlock()
	return fake.hasRoleForGroupArgsForCall[i].ctx, fake.hasRoleForGroupArgsForCall[i].in, fake.hasRoleForGroupArgsForCall[i].opts
}

func (fake *FakeRoleServiceClient) HasRoleForGroupReturns(result1 *protos.HasRoleForGroupResponse, result2 error) {
	fake.HasRoleForGroupStub = nil
	fake.hasRoleForGroupReturns = struct {
		result1 *protos.HasRoleForGroupResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) HasRoleForGroupReturnsOnCall(i int, result1 *protos.HasRoleForGroupResponse, result2 error) {
	fake.HasRoleForGroupStub = nil
	if fake.hasRoleForGroupReturnsOnCall == nil {
		fake.hasRoleForGroupReturnsOnCall = make(map[int]struct {
			result1 *protos.HasRoleForGroupResponse
			result2 error
		})
	}
	fake.hasRoleForGroupReturnsOnCall[i] = struct {
		result1 *protos.HasRoleForGroupResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) ListRolePermissions(ctx context.Context, in *protos.ListRolePermissionsRequest, opts ...grpc.CallOption) (*protos.ListRolePermissionsResponse, error) {
	fake.listRolePermissionsMutex.Lock()
	ret, specificReturn := fake.listRolePermissionsReturnsOnCall[len(fake.listRolePermissionsArgsForCall)]
	fake.listRolePermissionsArgsForCall = append(fake.listRolePermissionsArgsForCall, struct {
		ctx  context.Context
		in   *protos.ListRolePermissionsRequest
		opts []grpc.CallOption
	}{ctx, in, opts})
	fake.recordInvocation("ListRolePermissions", []interface{}{ctx, in, opts})
	fake.listRolePermissionsMutex.Unlock()
	if fake.ListRolePermissionsStub != nil {
		return fake.ListRolePermissionsStub(ctx, in, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listRolePermissionsReturns.result1, fake.listRolePermissionsReturns.result2
}

func (fake *FakeRoleServiceClient) ListRolePermissionsCallCount() int {
	fake.listRolePermissionsMutex.RLock()
	defer fake.listRolePermissionsMutex.RUnlock()
	return len(fake.listRolePermissionsArgsForCall)
}

func (fake *FakeRoleServiceClient) ListRolePermissionsArgsForCall(i int) (context.Context, *protos.ListRolePermissionsRequest, []grpc.CallOption) {
	fake.listRolePermissionsMutex.RLock()
	defer fake.listRolePermissionsMutex.RUnlock()
	return fake.listRolePermissionsArgsForCall[i].ctx, fake.listRolePermissionsArgsForCall[i].in, fake.listRolePermissionsArgsForCall[i].opts
}

func (fake *FakeRoleServiceClient) ListRolePermissionsReturns(result1 *protos.ListRolePermissionsResponse, result2 error) {
	fake.ListRolePermissionsStub = nil
	fake.listRolePermissionsReturns = struct {
		result1 *protos.ListRolePermissionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) ListRolePermissionsReturnsOnCall(i int, result1 *protos.ListRolePermissionsResponse, result2 error) {
	fake.ListRolePermissionsStub = nil
	if fake.listRolePermissionsReturnsOnCall == nil {
		fake.listRolePermissionsReturnsOnCall = make(map[int]struct {
			result1 *protos.ListRolePermissionsResponse
			result2 error
		})
	}
	fake.listRolePermissionsReturnsOnCall[i] = struct {
		result1 *protos.ListRolePermissionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeRoleServiceClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createRoleMutex.RLock()
	defer fake.createRoleMutex.RUnlock()
	fake.deleteRoleMutex.RLock()
	defer fake.deleteRoleMutex.RUnlock()
	fake.assignRoleMutex.RLock()
	defer fake.assignRoleMutex.RUnlock()
	fake.assignRoleToGroupMutex.RLock()
	defer fake.assignRoleToGroupMutex.RUnlock()
	fake.unassignRoleMutex.RLock()
	defer fake.unassignRoleMutex.RUnlock()
	fake.unassignRoleFromGroupMutex.RLock()
	defer fake.unassignRoleFromGroupMutex.RUnlock()
	fake.hasRoleMutex.RLock()
	defer fake.hasRoleMutex.RUnlock()
	fake.hasRoleForGroupMutex.RLock()
	defer fake.hasRoleForGroupMutex.RUnlock()
	fake.listRolePermissionsMutex.RLock()
	defer fake.listRolePermissionsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRoleServiceClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ protos.RoleServiceClient = new(FakeRoleServiceClient)
