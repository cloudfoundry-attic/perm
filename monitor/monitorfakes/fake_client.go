// Code generated by counterfeiter. DO NOT EDIT.
package monitorfakes

import (
	"context"
	"sync"
	"time"

	"code.cloudfoundry.org/perm"
	"code.cloudfoundry.org/perm/monitor"
)

type FakeClient struct {
	AssignRoleStub        func(ctx context.Context, roleName string, actor perm.Actor) (time.Duration, error)
	assignRoleMutex       sync.RWMutex
	assignRoleArgsForCall []struct {
		ctx      context.Context
		roleName string
		actor    perm.Actor
	}
	assignRoleReturns struct {
		result1 time.Duration
		result2 error
	}
	assignRoleReturnsOnCall map[int]struct {
		result1 time.Duration
		result2 error
	}
	CreateRoleStub        func(ctx context.Context, name string, permissions ...perm.Permission) (perm.Role, time.Duration, error)
	createRoleMutex       sync.RWMutex
	createRoleArgsForCall []struct {
		ctx         context.Context
		name        string
		permissions []perm.Permission
	}
	createRoleReturns struct {
		result1 perm.Role
		result2 time.Duration
		result3 error
	}
	createRoleReturnsOnCall map[int]struct {
		result1 perm.Role
		result2 time.Duration
		result3 error
	}
	DeleteRoleStub        func(ctx context.Context, name string) (time.Duration, error)
	deleteRoleMutex       sync.RWMutex
	deleteRoleArgsForCall []struct {
		ctx  context.Context
		name string
	}
	deleteRoleReturns struct {
		result1 time.Duration
		result2 error
	}
	deleteRoleReturnsOnCall map[int]struct {
		result1 time.Duration
		result2 error
	}
	HasPermissionStub        func(ctx context.Context, actor perm.Actor, action, resource string) (bool, time.Duration, error)
	hasPermissionMutex       sync.RWMutex
	hasPermissionArgsForCall []struct {
		ctx      context.Context
		actor    perm.Actor
		action   string
		resource string
	}
	hasPermissionReturns struct {
		result1 bool
		result2 time.Duration
		result3 error
	}
	hasPermissionReturnsOnCall map[int]struct {
		result1 bool
		result2 time.Duration
		result3 error
	}
	UnassignRoleStub        func(ctx context.Context, roleName string, actor perm.Actor) (time.Duration, error)
	unassignRoleMutex       sync.RWMutex
	unassignRoleArgsForCall []struct {
		ctx      context.Context
		roleName string
		actor    perm.Actor
	}
	unassignRoleReturns struct {
		result1 time.Duration
		result2 error
	}
	unassignRoleReturnsOnCall map[int]struct {
		result1 time.Duration
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) AssignRole(ctx context.Context, roleName string, actor perm.Actor) (time.Duration, error) {
	fake.assignRoleMutex.Lock()
	ret, specificReturn := fake.assignRoleReturnsOnCall[len(fake.assignRoleArgsForCall)]
	fake.assignRoleArgsForCall = append(fake.assignRoleArgsForCall, struct {
		ctx      context.Context
		roleName string
		actor    perm.Actor
	}{ctx, roleName, actor})
	fake.recordInvocation("AssignRole", []interface{}{ctx, roleName, actor})
	fake.assignRoleMutex.Unlock()
	if fake.AssignRoleStub != nil {
		return fake.AssignRoleStub(ctx, roleName, actor)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.assignRoleReturns.result1, fake.assignRoleReturns.result2
}

func (fake *FakeClient) AssignRoleCallCount() int {
	fake.assignRoleMutex.RLock()
	defer fake.assignRoleMutex.RUnlock()
	return len(fake.assignRoleArgsForCall)
}

func (fake *FakeClient) AssignRoleArgsForCall(i int) (context.Context, string, perm.Actor) {
	fake.assignRoleMutex.RLock()
	defer fake.assignRoleMutex.RUnlock()
	return fake.assignRoleArgsForCall[i].ctx, fake.assignRoleArgsForCall[i].roleName, fake.assignRoleArgsForCall[i].actor
}

func (fake *FakeClient) AssignRoleReturns(result1 time.Duration, result2 error) {
	fake.AssignRoleStub = nil
	fake.assignRoleReturns = struct {
		result1 time.Duration
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AssignRoleReturnsOnCall(i int, result1 time.Duration, result2 error) {
	fake.AssignRoleStub = nil
	if fake.assignRoleReturnsOnCall == nil {
		fake.assignRoleReturnsOnCall = make(map[int]struct {
			result1 time.Duration
			result2 error
		})
	}
	fake.assignRoleReturnsOnCall[i] = struct {
		result1 time.Duration
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateRole(ctx context.Context, name string, permissions ...perm.Permission) (perm.Role, time.Duration, error) {
	fake.createRoleMutex.Lock()
	ret, specificReturn := fake.createRoleReturnsOnCall[len(fake.createRoleArgsForCall)]
	fake.createRoleArgsForCall = append(fake.createRoleArgsForCall, struct {
		ctx         context.Context
		name        string
		permissions []perm.Permission
	}{ctx, name, permissions})
	fake.recordInvocation("CreateRole", []interface{}{ctx, name, permissions})
	fake.createRoleMutex.Unlock()
	if fake.CreateRoleStub != nil {
		return fake.CreateRoleStub(ctx, name, permissions...)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.createRoleReturns.result1, fake.createRoleReturns.result2, fake.createRoleReturns.result3
}

func (fake *FakeClient) CreateRoleCallCount() int {
	fake.createRoleMutex.RLock()
	defer fake.createRoleMutex.RUnlock()
	return len(fake.createRoleArgsForCall)
}

func (fake *FakeClient) CreateRoleArgsForCall(i int) (context.Context, string, []perm.Permission) {
	fake.createRoleMutex.RLock()
	defer fake.createRoleMutex.RUnlock()
	return fake.createRoleArgsForCall[i].ctx, fake.createRoleArgsForCall[i].name, fake.createRoleArgsForCall[i].permissions
}

func (fake *FakeClient) CreateRoleReturns(result1 perm.Role, result2 time.Duration, result3 error) {
	fake.CreateRoleStub = nil
	fake.createRoleReturns = struct {
		result1 perm.Role
		result2 time.Duration
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) CreateRoleReturnsOnCall(i int, result1 perm.Role, result2 time.Duration, result3 error) {
	fake.CreateRoleStub = nil
	if fake.createRoleReturnsOnCall == nil {
		fake.createRoleReturnsOnCall = make(map[int]struct {
			result1 perm.Role
			result2 time.Duration
			result3 error
		})
	}
	fake.createRoleReturnsOnCall[i] = struct {
		result1 perm.Role
		result2 time.Duration
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) DeleteRole(ctx context.Context, name string) (time.Duration, error) {
	fake.deleteRoleMutex.Lock()
	ret, specificReturn := fake.deleteRoleReturnsOnCall[len(fake.deleteRoleArgsForCall)]
	fake.deleteRoleArgsForCall = append(fake.deleteRoleArgsForCall, struct {
		ctx  context.Context
		name string
	}{ctx, name})
	fake.recordInvocation("DeleteRole", []interface{}{ctx, name})
	fake.deleteRoleMutex.Unlock()
	if fake.DeleteRoleStub != nil {
		return fake.DeleteRoleStub(ctx, name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deleteRoleReturns.result1, fake.deleteRoleReturns.result2
}

func (fake *FakeClient) DeleteRoleCallCount() int {
	fake.deleteRoleMutex.RLock()
	defer fake.deleteRoleMutex.RUnlock()
	return len(fake.deleteRoleArgsForCall)
}

func (fake *FakeClient) DeleteRoleArgsForCall(i int) (context.Context, string) {
	fake.deleteRoleMutex.RLock()
	defer fake.deleteRoleMutex.RUnlock()
	return fake.deleteRoleArgsForCall[i].ctx, fake.deleteRoleArgsForCall[i].name
}

func (fake *FakeClient) DeleteRoleReturns(result1 time.Duration, result2 error) {
	fake.DeleteRoleStub = nil
	fake.deleteRoleReturns = struct {
		result1 time.Duration
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteRoleReturnsOnCall(i int, result1 time.Duration, result2 error) {
	fake.DeleteRoleStub = nil
	if fake.deleteRoleReturnsOnCall == nil {
		fake.deleteRoleReturnsOnCall = make(map[int]struct {
			result1 time.Duration
			result2 error
		})
	}
	fake.deleteRoleReturnsOnCall[i] = struct {
		result1 time.Duration
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) HasPermission(ctx context.Context, actor perm.Actor, action string, resource string) (bool, time.Duration, error) {
	fake.hasPermissionMutex.Lock()
	ret, specificReturn := fake.hasPermissionReturnsOnCall[len(fake.hasPermissionArgsForCall)]
	fake.hasPermissionArgsForCall = append(fake.hasPermissionArgsForCall, struct {
		ctx      context.Context
		actor    perm.Actor
		action   string
		resource string
	}{ctx, actor, action, resource})
	fake.recordInvocation("HasPermission", []interface{}{ctx, actor, action, resource})
	fake.hasPermissionMutex.Unlock()
	if fake.HasPermissionStub != nil {
		return fake.HasPermissionStub(ctx, actor, action, resource)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.hasPermissionReturns.result1, fake.hasPermissionReturns.result2, fake.hasPermissionReturns.result3
}

func (fake *FakeClient) HasPermissionCallCount() int {
	fake.hasPermissionMutex.RLock()
	defer fake.hasPermissionMutex.RUnlock()
	return len(fake.hasPermissionArgsForCall)
}

func (fake *FakeClient) HasPermissionArgsForCall(i int) (context.Context, perm.Actor, string, string) {
	fake.hasPermissionMutex.RLock()
	defer fake.hasPermissionMutex.RUnlock()
	return fake.hasPermissionArgsForCall[i].ctx, fake.hasPermissionArgsForCall[i].actor, fake.hasPermissionArgsForCall[i].action, fake.hasPermissionArgsForCall[i].resource
}

func (fake *FakeClient) HasPermissionReturns(result1 bool, result2 time.Duration, result3 error) {
	fake.HasPermissionStub = nil
	fake.hasPermissionReturns = struct {
		result1 bool
		result2 time.Duration
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) HasPermissionReturnsOnCall(i int, result1 bool, result2 time.Duration, result3 error) {
	fake.HasPermissionStub = nil
	if fake.hasPermissionReturnsOnCall == nil {
		fake.hasPermissionReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 time.Duration
			result3 error
		})
	}
	fake.hasPermissionReturnsOnCall[i] = struct {
		result1 bool
		result2 time.Duration
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) UnassignRole(ctx context.Context, roleName string, actor perm.Actor) (time.Duration, error) {
	fake.unassignRoleMutex.Lock()
	ret, specificReturn := fake.unassignRoleReturnsOnCall[len(fake.unassignRoleArgsForCall)]
	fake.unassignRoleArgsForCall = append(fake.unassignRoleArgsForCall, struct {
		ctx      context.Context
		roleName string
		actor    perm.Actor
	}{ctx, roleName, actor})
	fake.recordInvocation("UnassignRole", []interface{}{ctx, roleName, actor})
	fake.unassignRoleMutex.Unlock()
	if fake.UnassignRoleStub != nil {
		return fake.UnassignRoleStub(ctx, roleName, actor)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.unassignRoleReturns.result1, fake.unassignRoleReturns.result2
}

func (fake *FakeClient) UnassignRoleCallCount() int {
	fake.unassignRoleMutex.RLock()
	defer fake.unassignRoleMutex.RUnlock()
	return len(fake.unassignRoleArgsForCall)
}

func (fake *FakeClient) UnassignRoleArgsForCall(i int) (context.Context, string, perm.Actor) {
	fake.unassignRoleMutex.RLock()
	defer fake.unassignRoleMutex.RUnlock()
	return fake.unassignRoleArgsForCall[i].ctx, fake.unassignRoleArgsForCall[i].roleName, fake.unassignRoleArgsForCall[i].actor
}

func (fake *FakeClient) UnassignRoleReturns(result1 time.Duration, result2 error) {
	fake.UnassignRoleStub = nil
	fake.unassignRoleReturns = struct {
		result1 time.Duration
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UnassignRoleReturnsOnCall(i int, result1 time.Duration, result2 error) {
	fake.UnassignRoleStub = nil
	if fake.unassignRoleReturnsOnCall == nil {
		fake.unassignRoleReturnsOnCall = make(map[int]struct {
			result1 time.Duration
			result2 error
		})
	}
	fake.unassignRoleReturnsOnCall[i] = struct {
		result1 time.Duration
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.assignRoleMutex.RLock()
	defer fake.assignRoleMutex.RUnlock()
	fake.createRoleMutex.RLock()
	defer fake.createRoleMutex.RUnlock()
	fake.deleteRoleMutex.RLock()
	defer fake.deleteRoleMutex.RUnlock()
	fake.hasPermissionMutex.RLock()
	defer fake.hasPermissionMutex.RUnlock()
	fake.unassignRoleMutex.RLock()
	defer fake.unassignRoleMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ monitor.Client = new(FakeClient)
